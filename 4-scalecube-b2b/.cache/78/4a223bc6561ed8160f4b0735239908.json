{"id":"ayiE","dependencies":[{"name":"/home/idan/prj/playground/micro-frontends/node_modules/rxjs/operator/catch.js.map","includedInParent":true,"mtime":499162500000},{"name":"/home/idan/prj/playground/micro-frontends/package.json","includedInParent":true,"mtime":1538321389029},{"name":"/home/idan/prj/playground/micro-frontends/node_modules/rxjs/package.json","includedInParent":true,"mtime":499162500000},{"name":"../operators/catchError","loc":{"line":2,"column":27},"parent":"/home/idan/prj/playground/micro-frontends/node_modules/rxjs/operator/catch.js","resolved":"/home/idan/prj/playground/micro-frontends/node_modules/rxjs/operators/catchError.js"}],"generated":{"js":"\"use strict\";var r=require(\"../operators/catchError\");function t(t){return r.catchError(t)(this)}exports._catch=t;","map":{"mappings":[{"source":"../../src/operator/catch.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":1,"column":13}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":1,"column":17}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":1,"column":19}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":3,"column":42},"generated":{"line":1,"column":27}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":64,"column":0},"generated":{"line":1,"column":54}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":64,"column":0},"generated":{"line":1,"column":63}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":64,"column":50},"generated":{"line":1,"column":65}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":65,"column":2},"generated":{"line":1,"column":68}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":65,"column":9},"generated":{"line":1,"column":75}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":65,"column":9},"generated":{"line":1,"column":77}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":65,"column":21},"generated":{"line":1,"column":88}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":65,"column":9},"generated":{"line":1,"column":90}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":65,"column":31},"generated":{"line":1,"column":91}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":64,"column":16},"generated":{"line":1,"column":97}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":64,"column":16},"generated":{"line":1,"column":105}},{"source":"../../src/operator/catch.ts","name":null,"original":{"line":64,"column":22},"generated":{"line":1,"column":112}}],"sources":{"../../src/operator/catch.ts":"\nimport { Observable, ObservableInput } from '../Observable';\nimport { catchError as higherOrder } from '../operators/catchError';\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @method catch\n * @name catch\n * @owner Observable\n */\nexport function _catch<T, R>(this: Observable<T>, selector: (err: any, caught: Observable<T>) => ObservableInput<R>): Observable<T | R> {\n  return higherOrder(selector)(this);\n}\n"},"lineCount":null}},"hash":"8cad2ac5dd2d68f04ca394f7d56f5765","cacheData":{"env":{}}}